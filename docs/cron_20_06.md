# Zadania cykliczne - wysyłaj maile codziennie, do kogo trzeba

<a href="#co-chcemy-uzyska%C4%87">Co chcemy uzyskać?</a><br>
<a href="#og%C3%B3lne-kroki-do-podj%C4%99cia">Ogólne kroki do podjęcia</a><br>
<a href="#rake-task">Rake task</a><br>
<a href="#whenever---wrzu%C4%87my-task-w-harmonogram-zada%C5%84">Whenever - wrzućmy task w harmonogram zadań</a><br>
<a href="#c9-rufus-scheduler">C9 niewspółpracujące z CRON-em: Rufus-Scheduler</a><br>

<br>

**Uwaga** - tutorial zakłada, że masz wykonane zmiany (przygotowane mailery) z <a href='https://github.com/infakt/atelier_june_2018/blob/sidekiq_20_06/docs/sidekiq_20_06.md'>ćwiczenia z zadań w tle</a>- będziemy je wykorzystywali. Jeżeli miałeś problem z tym zadaniem - głowa do góry!<br> Przygotowaliśmy dwa gotowe rozwiązania, z opisem, od których możesz startować:
* <a href='https://github.com/infakt/atelier_june_2018/blob/background_jobs_solution_DELAYED_JOB/doc/background_jobs_solution_DELAYED_JOB.md'>DelyedJob</a>
* <a href='https://github.com/infakt/atelier_june_2018/blob/background_jobs_solution_SIDEKIQ/doc/background_jobs_solution_SIDEKIQ.md'>Sidekiq</a>
<br>

**Uwaga2** - jeżeli korzystasz z C9 - będziesz musiał prawdopodobnie <a href="#c9-rufus-scheduler">zrezygnować z CRON-a</a><br>
Przy rozwiązywaniu zadania - miej pod ręką prezentację z zajęć.<br>
Możesz mieć **problem z wersją Ruby'ego** - pamiętaj, żeby dodać plik `.ruby-version` do głównego folderu aplikacji

<br>

## Co chcemy uzyskać?

* Codziennie, o godzinie 8:00, chcemy **zbierać wszystkie rezerwacje w statusie `TAKEN`, których `expires_at` jest jutro (`Date.tomorrow`)**
* mając taką kolekcję rezerwacji - przelatujemy po nich `each'em` i odpalamy nasze mailery dla powiązanej z każdą rezerwacją książki
* **uwaga** - `expires_at` jest oznaczeniem datą i godziną. Uważaj na to, w jaki sposób "zagarniasz" wygasające rezerwacje
**Proponowane rozwiązania tego problemu - na końcu tutoriala: <a href="#jak-przeskoczyc-problem-z-expire_at">expires_at</a><br>**
<br>

* **WAŻNE** : w ramach tego tutoriala pokażemy rozwiązanie "podobnego", ale innego zadania! (tak, jak zrobiliśmy to z mailerami)
* wyobraźmy sobie (nieco abstrakcyjnie), że 15go dnia każdego miesiąca, o 10:30 - zbieramy userów, którzy mają > 20 rezerwacji i... cancelujemy ich rezerwacje, bo najwyraźniej są jakimiś trollami


## Ogólne kroki do podjęcia

* Stworzyć `rake task`, który będzie odpowiedzialny za wykonanie całej logiki zadania
* dodać + odpalić gem `whenever`
* odpowiednio skonfigurować `schedule`, żeby wykonywał się w odpowiednich momentach


## Rake task

* rake taski trzymamy w folderze **`lib/tasks`**
* żeby task mógł się wykonać - musi mieć **rozszerzenie `.rake`**
* **nazwa pliku to tzw. _namespace_**, czyli nazwa "zbioru" tasków w danym pliku, czego dotyczą
* wewnątrz jednego pliku - i danego namespace'u możemy mieć kilka tasków
```ruby
# lib/tasks/my_namespace.rake
namespace :my_namespace do
  desc "My Task 1"
  task my_task1: :environment do
  end

  desc "My Task 1"
  task my_task2: :environment do
  end
end
```
* odpalamy taski przy pomocy **`rake namespace:task`**, np: `rake my_namespace:my_task1`
* nasz rake task
```ruby
# lib/tasks/reservation.rake
namespace :reservation do
  desc "Cancel too much reservation"
  task cancel_overreserved: :environment do
    users = User.joins(:reservations).group('users.id').having('count(user_id) > 20')
    users.each do |user|
      user.reservations.each { |reservation| reservation.update_attributes(status: 'CANCELED') }
    end
  end
end
```

## Whenever - wrzućmy task w harmonogram zadań

* https://github.com/javan/whenever
* dodajemy do Gemfile'a `gem 'whenever', require: false
* 'wheneverizujemy' naszą aplikację - `wheneverize .`
* dodajemy do **terminarza** (`/config/schedule.rb`) wywołanie naszego taska
```ruby
# config/schedule.rb
every '0 0 15 * *' do
  rake 'reservation:cancel_overreserved', environment: 'development'
end
```
* odpalamy **update crontaba**
```ruby
whenever --update-crontab
```

* na koniec sprawdźmy, co zawiera tablica zadań do wykonanai - crontab
```
crontab -l
# Begin Whenever generated tasks for: /Users/…/atelier/config/schedule.rb

* * * * * /bin/bash -l -c 'cd /Users/…/atelier && RAILS_ENV=development bundle exec rake reservation:cancel_overreserved --silent'

# End Whenever generated tasks for: /Users/…/atelier/config/schedule.rb
```

**BANG!**
Wszystko powinno śmigać :)

## C9-Rufus Scheduler

Niestety C9 najwyraźniej nie pozwala na edycję CRON-owe.<br>
Działa `crontab -l`, działa edycja `crontab -e`... ale co z tego, jak nic się nie wykonuje :) <br>
Google nie pomógł i nie wie dlaczego więc do celów dydaktycznych - wykorzystamy **gem Rufus-Scheduler**

* gem: https://github.com/jmettraux/rufus-scheduler
* dodajemy go do `Gemfile-a`, bundujemy
* zadania będziemy dodawali w `initializerze` - np. `config/initializers/scheduler.rb`
** wszystki pliki z folderu `initializers` odpalane są razem z aplikacją
** ich nazwa może być dowolna, ale powinna mówić o co chodzi
** oznacza to też niestety, ze **w przeciwieństwie do CRON-a, który działa _systemowo_ - działanie tasków zdefiniowanych tutaj zależy tego, czy aplikacja jest uruchomiona**
* jak powinien wyglądać plik `scheduler.rb`
** musimy 'zaciągnąć' odpowiedni plik
** następnie stworzyć sobie nowy obiekt Scheduler-a
** i wreszcie zlecić mu zadanie (takie jak opisane w treści 'cronowej')

```ruby
# config/initializers/scheduler.rb
require 'rufus-scheduler'

scheduler = Rufus::Scheduler.new

scheduler.cron '0 0 15 * *' do
  system("rake reservation:cancel_overreserved")
end
```

## Jak przeskoczyc problem z expire_at

Propozycje rozwiązania

```ruby
Reservation.where('DATE(expires_at) = ?', Date.tomorrow)
Reservation.where(expires_at: Date.tomorrow.all_day) #UWAGA: RAILS 5
Reservation.where(expires_at: Date.tomorrow.beginning_of_day..Date.tomorrow.end_of_day)
```
